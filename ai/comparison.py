from sentence_transformers import SentenceTransformer
from sklearn.metrics.pairwise import cosine_similarity
import re
from collections import Counter
from sklearn.feature_extraction.text import ENGLISH_STOP_WORDS

# Load a lightweight sentence embedding model from Hugging Face
# 'all-MiniLM-L6-v2' provides a good balance between speed and semantic accuracy
model = SentenceTransformer("all-MiniLM-L6-v2")


def compare_outlines(actual_outline, ai_outline):
    """
    Compares the actual course outline with the AI-generated outline using
    sentence embeddings and cosine similarity.

    Args:
        actual_outline (str): The actual topics/modules from the course
        ai_outline (str): The outline generated by the AI

    Returns:
        float: Cosine similarity score between 0 and 1
    """

    # Encode both outlines into high-dimensional vector representations
    actual_embedding = model.encode([actual_outline])
    ai_embedding = model.encode([ai_outline])

    # Compute cosine similarity between the two vectors
    similarity = cosine_similarity(actual_embedding, ai_embedding)[0][0]

    # Return the similarity score (1 = identical, 0 = no similarity)
    return similarity


def extract_keywords_and_counts(text):
    # Tokenize and lowercase
    words = re.findall(r"\b\w+\b", text.lower())
    # Remove stopwords
    keywords = [word for word in words if word not in ENGLISH_STOP_WORDS]
    keyword_set = set(keywords)
    word_count = len(keywords)
    top_keywords = Counter(keywords).most_common(10)
    return keyword_set, word_count, top_keywords


def compare_outlines_keywords(actual_outline, ai_outline):
    """
    Compares outlines using keyword overlap (Jaccard similarity) and also returns top words and word counts.

    Returns:
        dict with similarity score, word counts, and top 10 common words from each outline.
    """
    actual_keywords, actual_word_count, actual_top = extract_keywords_and_counts(
        actual_outline
    )
    ai_keywords, ai_word_count, ai_top = extract_keywords_and_counts(ai_outline)

    if not actual_keywords or not ai_keywords:
        similarity = 0.0
    else:
        intersection = actual_keywords & ai_keywords
        union = actual_keywords | ai_keywords
        similarity = len(intersection) / len(union)

    return {
        "similarity_score": similarity,
        "actual_word_count": actual_word_count,
        "ai_word_count": ai_word_count,
        "actual_top_words": actual_top,
        "ai_top_words": ai_top,
    }
